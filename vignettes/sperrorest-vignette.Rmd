---
title: "sperrorest-vignette: Spatial modeling using statistical learning techniques"
author: "Alexander Brenning, Patrick Schratz"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{sperrorest-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r, echo=FALSE, cache=FALSE}
library(knitr)
opts_chunk$set(cache = TRUE,
               fig.align = "center",
               collapse = TRUE,
               fig.width = 7,
               fig.height = 5)
opts_knit$set(width = 125)
```

# Data and packages

```{r, message=FALSE}
library(rpart)
library(MASS)
library(randomForest)
library(sperrorest)
```

The `maipo` data set from Marco Pena is used. 
```{r}
data("maipo", package = "sperrorest")

data("ecuador", package = "sperrorest")
```

Variable description:

**Response**  
  - `croptype`: response variable (factor) with 4 levels  
  
**Predictors**  
  - `b`[12-87]: spectral data, e.g. b82 = image date #8, spectral band #2  
  - `ndvi`[01-08]: Normalized Differenced Vegetation Index, e.g. #8 = image date #8  
  - `ndwi`[01-08]: Normalized Differenced Water Index, e.g. #8 = image date #8  
  
**Others**  
  - `field`: field identifier (grouping variable - not to be used as predictor)  
  - `utmx`, `utm`y: x/y location; not to be used as predictors  

# Preprocessing

Transform some of the predictor variables:

```{r}
predictors <- colnames(maipo)[5:ncol(maipo)]
# Construct a formula:
fo <- as.formula(paste("croptype ~", paste(predictors, collapse = "+")))
```

Take a quick look at (some) correlations among the predictors:
```{r}
co <- abs(cor(maipo[, predictors]) * 100)
co[co < 70] <- 0 # mask out weak/moderate correlations
head(round(co))
```


# Modeling

## Linear discriminant analysis (LDA)

Fit a model with all predictors:
```{r}
fit <- MASS::lda(fo, data = maipo)
```

Predict the croptype with the fitted model and calculate the average misclassification error rate (MER):
```{r}
pred <- predict(fit, newdata = maipo)$class
mean(pred != maipo$croptype)
```

Take a look at the confusion matrix:
```{r}
table(pred = pred, obs = maipo$croptype)
```


## Classification Tree

Fit a model with all predictors:

```{r}
fit <- rpart(fo, data = maipo)
#            control = rpart.control(cp=0.01))

## optional: view the classiciation tree
# par(xpd = TRUE)
# plot(fit)
# text(fit, use.n = TRUE)
```

Again, predict the croptype with the fitted model and calculate the average MER:
```{r}
pred <- predict(fit, newdata = maipo, type = "class")
mean(pred != maipo$croptype)
```

And take a look at the confusion matrix:
```{r}
table(pred = pred, obs = maipo$croptype)
```

Note that some classes may be over-/underpredicted, i.e. remotely-sensed crop areas can be biased even if accuracy is high!:

```{r}
summary(pred)
summary(maipo$croptype)
```

## Random Forest

(This will take some time...)
```{r}
fit <- randomForest(fo, data = maipo, importance = TRUE)
fit
```

Variable importance plot:
```{r}
varImpPlot(fit, type = 1, pch = 19, col = "blue", 
           main = "Permutation-based variable importance")
```

Variable importance plots for specific crop types
```{r}
partialPlot(fit, maipo, x.var = "ndvi01", which.class = "crop1")
partialPlot(fit, maipo, x.var = "ndvi01", which.class = "crop3")
```

Training-set misclassification error rate (MER) 
```{r}
pred <- predict(fit, newdata = maipo, type = "class")
mean(pred != maipo$croptype)
```

Confusion matrix:
```{r}
table(pred = pred, obs = maipo$croptype)
```

- No misclassification at all!
- Even RF's OOB (out-of-bag) estimate of the error rate is <1%.
- Too good to be true? We'll see...


# Cross-validation estimation of predictive performance

# LDA

We need to set up some functions to create a wrapper predict function of the LDA model for `sperrorest`. 

```{r}
library(nnet)
majority <- function(x) {
  levels(x)[which.is.max(table(x))]
}
```

```{r}
majority.filter <- function(x, fac) {
  for (lev in levels(fac)) {
    x[ fac == lev ] <- majority(x[ fac == lev ])
  }
  x
}
```

```{r}
lda.predfun <- function(object, newdata, fac = NULL) {
  pred <- predict(object, newdata = newdata)$class
  if (!is.null(fac)) pred <- majority.filter(pred, newdata[,fac]) 
  return(pred)
}
```

Finally, we can run `sperrorest` with a non-spatial sampling setup (`partition.cv`):

```{r}
res.lda.nsp <- res <- sperrorest(fo, data = maipo, coords = c("utmx","utmy"), 
                                 model.fun = lda,
                                 pred.fun = lda.predfun, 
                                 pred.args = list(fac = "field"),
                                 smp.fun = partition.cv, 
                                 smp.args = list(repetition = 1:4, nfold = 5),
                                 err.rep = TRUE, err.fold = FALSE)
round(summary(res.lda.nsp$err.rep), 3)
```

To run a spatial cross-validation at the field level, we can use `partition.factor.cv` as the sampling function. Subsequently, we have to specify the location of the fields. We can do so using the `field` variable of our data set and put in `smp.args`: 

```{r}
res.lda.sp <- sperrorest(fo, data = maipo, coords = c("utmx","utmy"), 
                         model.fun = lda,
                         pred.fun = lda.predfun, 
                         pred.args = list(fac = "field"),
                         smp.fun = partition.factor.cv, 
                         smp.args = list(fac = "field", repetition = 1:4, nfold = 5),
                         err.rep = TRUE, err.fold = FALSE)
round(summary(res.lda.sp$err.rep), 3)
```

# RF

Setup prediction function for random forest:
```{r}
rf.predfun <- function(object, newdata, fac = NULL) {
  pred <- predict(object, newdata = newdata)
  if (!is.null(fac)) pred <- majority.filter(pred, newdata[,fac]) 
  return(pred)
}
```

Perform spatial cross-validation at the field level. Executing every repetition sequentially takes quite some time. we can take the parallelized versions of `sperrorest`, `parsperrorest` or `sperrorest.par`.

The advantage of `sperrorest.par` is that you can the progress of your current run. For Unix-Systems, the progress is directly reported to the console. For Windows, it is written to a textfile named "sperrorest.txt" in your current working directory.
```{r}
res.rf.sp <- sperrorest(fo, data = maipo, coords = c("utmx","utmy"), 
                        model.fun = randomForest,
                        pred.fun = rf.predfun, 
                        pred.args = list(fac = "field"),
                        smp.fun = partition.factor.cv,
                        smp.args = list(fac = "field", 
                                        repetition = 1:4, nfold = 5),
                        err.rep = TRUE, err.fold = FALSE,
                        benchmark = TRUE, silent = FALSE)
res.rf.sp$benchmark
```

Läuft mit par.mode = 1
```{r}
res.rf.sp.par <- parsperrorest(fo, data = maipo, coords = c("utmx","utmy"), 
                               model.fun = randomForest,
                               pred.fun = rf.predfun, 
                               pred.args = list(fac = "field"),
                               smp.fun = partition.factor.cv,
                               smp.args = list(fac = "field", 
                                               repetition = 1:4, nfold = 5),
                               par.args = list(par.mode = 1, par.units = 2, 
                                               lb = T, high = TRUE),
                               err.rep = TRUE, err.fold = FALSE,
                               benchmark = TRUE, silent = FALSE)
res.rf.sp.par$benchmark
```


Läuft nicht (accumulate errors in foreach .combine) 
```{r, eval = FALSE}
res.rf.sp.par1 <- sperrorest.par(fo, data = maipo, coords = c("utmx","utmy"), 
                                 model.fun = randomForest,
                                 pred.fun = rf.predfun, 
                                 pred.args = list(fac = "field"),
                                 smp.fun = partition.factor.cv,
                                 smp.args = list(fac = "field", 
                                                 repetition = 1:4, nfold = 5),
                                 par.units = 2, silent = 2,
                                 err.fold = T, err.rep = T,
                                 benchmark = TRUE)
res.rf.sp.par1$benchmark
```

