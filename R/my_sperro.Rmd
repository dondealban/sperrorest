---
title: "sperrorest parallelization"
author: "Patrick Schratz"
output:
  rmdformats::html_clean:
    highlight: kate
---

```{r, echo=FALSE, cache=FALSE}
library(knitr)
library(rmdformats)

## Global options
options(max.print = "75")
opts_chunk$set(echo = TRUE,
               eval = TRUE,
	             cache = TRUE,
               prompt = FALSE,
               tidy = TRUE,
               comment = NA,
               message = FALSE,
               warning = FALSE)
opts_knit$set(width = 75)
```

```{r define function, echo = FALSE}
mysperro <- function(formula, data, coords = c("x", "y"), 
                     model.fun, model.args = list(), 
                     pred.fun = NULL, pred.args = list(), 
                     smp.fun = partition.loo, 
                     smp.args = list(), train.fun = NULL, train.param = NULL, 
                     test.fun = NULL, test.param = NULL, err.fun = err.default, 
                     err.unpooled = TRUE, err.pooled = FALSE, err.train = TRUE, 
                     imp.variables = NULL, imp.permutations = 1000, 
                     importance = !is.null(imp.variables),
                     distance = FALSE, do.gc = 1, do.try = FALSE, silent = 1, 
                     parallel = FALSE, cores = detectCores()/2, progress = "",
                     ...) 
{
  if (missing(model.fun)) 
    stop("'model.fun' is a required argument")
  if (as.character(attr(terms(formula), "variables"))[3] == 
      "...") 
    stop("formula of the form lhs ~ ... not accepted by
             'sperrorest'\nspecify all predictor variables explicitly")
  stopifnot(is.function(model.fun))
  stopifnot(is.function(smp.fun))
  if (!is.null(train.fun)) 
    stopifnot(is.function(train.fun))
  if (!is.null(test.fun)) 
    stopifnot(is.function(test.fun))
  stopifnot(is.function(err.fun))
  if (importance) {
    if (!err.unpooled) {
      warning("'importance=TRUE' currently only supported 
                    with 'err.unpooled=TRUE'.\nUsing 'importance=FALSE'")
      importance = FALSE
    }
    stopifnot(is.numeric(imp.permutations))
    if (!is.null(imp.variables)) 
      stopifnot(is.character(imp.variables))
  }
  stopifnot(is.character(coords))
  stopifnot(length(coords) == 2)
  if (importance & !err.unpooled) 
    stop("variable importance assessment currently only supported 
             at the unpooled level")
  if (any(names(model.args) == "formula")) 
    stop("'model.args' cannot have a 'formula' element")
  if (any(names(model.args) == "data")) 
    stop("'model.args' cannot have a 'data' element")
  if (any(names(pred.args) == "object")) 
    stop("'pred.args' cannot have an 'object' element:\n
             this will be generated by 'sperrorest'")
  if (any(names(pred.args) == "newdata")) 
    stop("'pred.args' cannot have a 'newdata' element:\n
             this will be generated by 'sperrorest'")
  dots.args <- list(...)
  if (length(dots.args) > 0) {
    if (any(names(dots.args) == "predfun")) 
      stop("sorry: argument names have changed; 
                 'predfun' is now 'pred.fun'")
    if (any(names(dots.args) == "model")) 
      stop("sorry: argument names have changed; 
                 'model' is now 'model.fun'")
    if (any(names(dots.args) == "err.combined")) 
      stop("sorry: argument names have changed; 
                 'err.combined' is now 'err.pooled'")
    if (any(names(dots.args) == "err.uncombined")) 
      stop("sorry: argument names have changed; 
                 'err.uncombined' is now 'err.unpooled'")
    warning("'...' arguments currently not supported:\n
                use 'model.args' to pass list of additional 
                arguments to 'model.fun'")
  }
  if (cores > parallel::detectCores())
    stop("More cores specificied than available. 
             Check number of available cores with 'detectCores()'.")
  response <- as.character(attr(terms(formula), "variables"))[2]
  smp.args$data <- data
  smp.args$coords <- coords
  resamp <- do.call(smp.fun, args = smp.args)
  if (distance) 
    resamp <- add.distance(resamp, data, coords = coords, 
                           fun = mean)
  if (err.unpooled) {
    res <- lapply(resamp, unclass)
    class(res) <- "sperroresterror"
  }
  else {
    res <- NULL
  }
  pooled.err <- NULL
  is.factor.prediction <- NULL
  impo <- NULL
  if (importance) {
    if (is.null(imp.variables)) {
      imp.variables = strsplit(as.character(formula)[3], 
                               " + ", fixed = TRUE)[[1]]
    }
    impo <- resamp
    imp.one.rep <- as.list(rep(NA, length(imp.variables)))
    names(imp.one.rep) <- imp.variables
    tmp <- as.list(rep(NA, imp.permutations))
    names(tmp) <- as.character(1:imp.permutations)
    for (vnm in imp.variables) {
      imp.one.rep[[vnm]] <- tmp
    }
    rm(tmp)
  }
  
  if (parallel) {
    library(doParallel, quietly = TRUE) 
    library(foreach, quietly = TRUE) 
    
    if (progress == "" & Sys.info()["sysname"] == "Windows")
      progress <- paste0(getwd(), "/sperrorest.progress.txt")
    
    cl <- makeCluster(cores, outfile = progress)
    registerDoParallel(cl, cores = cores)
    
    foreach.out <- foreach(i = 1:length(resamp), 
                           .packages = (.packages()), 
                           .errorhandling = "remove", 
                           .combine = rbind, .verbose = FALSE) %dopar% {
                             
                             # reset pooled.err otherwise 
                             # duplicates are introduced
                             pooled.err <- NULL
                             
                             if (silent == 1) {
                               cat(date(), "Repetition", 
                                   names(resamp)[i], "\n") 
                             }
                             if (err.train) {
                               pooled.obs.train = pooled.pred.train = c()
                             pooled.obs.test = pooled.pred.test = c()
                             }
                             for (j in 1:length(resamp[[i]])) {
                               if (silent == 2) {
                                 cat(date(), "Repetition", 
                                     names(resamp)[i], "- Fold", j, "\n") 
                               }
                               nd <- data[resamp[[i]][[j]]$train, ]
                               if (!is.null(train.fun)) {
                                 nd <- train.fun(data = nd, param = train.param)
                               }
                               margs <- c(list(formula = formula, data = nd),
                                          model.args)
                               if (do.try) {
                                 fit <- try(do.call(model.fun, args = margs),
                                            silent = silent)
                                 if (class(fit) == "try-error") {
                                   fit <- NULL
                                   if (err.unpooled) {
                                     if (err.train) {
                                       res[[i]][[j]]$train <- NULL
                                     }
                                     res[[i]][[j]]$test <- NULL
                                     if (importance) {
                                       impo[[i]][[j]] = c()
                                     }
                                   }
                                   if (do.gc >= 2) {
                                     gc()
                                   }
                                   next
                                 }
                               }
                               else {
                                 fit <- do.call(model.fun, args = margs)
                               }
                               if (err.train) {
                                 pargs <- c(list(object = fit, newdata = nd),
                                            pred.args)
                                 if (is.null(pred.fun)) {
                                   pred.train <- do.call(predict, args = pargs)
                                 }
                                 else {
                                   pred.train <- do.call(pred.fun, 
                                                         args = pargs)
                                 }
                                 rm(pargs)
                                 if (err.unpooled) 
                                   if (do.try) {
                                     err.try <- try(err.fun(nd[, response],
                                                            pred.train), 
                                                    silent = silent)
                                     if (class(err.try) == "try-error") 
                                       err.try <- NULL
                                     res[[i]][[j]]$train <- err.try
                                   }
                                 else {
                                   res[[i]][[j]]$train <- err.fun(
                                     nd[, response], pred.train)
                                 }
                                 if (err.pooled) {
                                   pooled.obs.train <- c(pooled.obs.train, 
                                                         nd[, response])
                                   pooled.pred.train <- c(pooled.pred.train,
                                                          pred.train)
                                 }
                               }
                               else {
                                 if (err.unpooled) {
                                   res[[i]][[j]]$train <- NULL
                                 }
                               }
                               nd <- data[resamp[[i]][[j]]$test, ]
                               if (!is.null(test.fun)) {
                                 nd <- test.fun(data = nd, param = test.param)
                               }
                               if (importance) {
                                 nd.bak <- nd
                               }
                               pargs <- c(list(object = fit, newdata = nd),
                                          pred.args)
                               if (is.null(pred.fun)) {
                                 pred.test <- do.call(predict, args = pargs)
                               }
                               else {
                                 pred.test <- do.call(pred.fun, args = pargs)
                               }
                               rm(pargs)
                               if (err.unpooled) {
                                 if (do.try) {
                                   err.try <- try(err.fun(
                                     nd[, response],pred.test), silent = silent)
                                   if (class(err.try) == "try-error") 
                                     err.try <- NULL
                                   res[[i]][[j]]$test <- err.try
                                 }
                                 else {
                                   res[[i]][[j]]$test <- err.fun(
                                     nd[, response], pred.test)
                                 }
                               }
                               if (err.pooled) {
                                 pooled.obs.test <- c(pooled.obs.test, 
                                                      nd[, response])
                                 pooled.pred.test <- c(pooled.pred.test,
                                                       pred.test)
                                 is.factor.prediction <- is.factor(pred.test)
                               }
                               if (importance & err.unpooled) {
                                 if (is.null(res[[i]][[j]]$test)) {
                                   impo[[i]][[j]] <- c()
                                   if (silent == 1 | silent == 2) 
                                     cat(date(), 
                                         "-- skipping variable importance\n")
                                 }
                                 else {
                                   if (silent == 1 | silent == 2) {
                                     cat(date(), "-- Variable importance\n")
                                   }
                                   imp.temp <- imp.one.rep
                                   for (cnt in 1:imp.permutations) {
                                     if (silent == 1 | silent == 2 & 
                                         (cnt > 1)) 
                                       if (log10(cnt) == floor(log10(cnt))) 
                                         cat(date(), "   ", cnt, "\n")
                                     permut <- sample(1:nrow(nd), 
                                                      replace = FALSE)
                                     for (vnm in imp.variables) {
                                       nd <- nd.bak
                                       nd[, vnm] <- nd[, vnm][permut]
                                       pargs <- c(list(object = fit, 
                                                       newdata = nd), 
                                                  pred.args)
                                       if (is.null(pred.fun)) {
                                         pred.test <- do.call(predict, 
                                                              args = pargs)
                                       }
                                       else {
                                         pred.test <- do.call(pred.fun, 
                                                              args = pargs)
                                       }
                                       rm(pargs)
                                       if (do.try) {
                                         permut.err <- try(err.fun(
                                           nd[, response], 
                                           pred.test), silent = silent)
                                         if (class(permut.err) == "try-error") {
                                           imp.temp[[vnm]][[cnt]] = c()
                                         }
                                         else {
                                           imp.temp[[vnm]][[cnt]] <- as.list(
                                             unlist(
                                               res[[i]][[j]]$test) - 
                                               unlist(permut.err))
                                         }
                                       }
                                       else {
                                         permut.err <- err.fun(nd[, response], 
                                                               pred.test)
                                         imp.temp[[vnm]][[cnt]] <- as.list(
                                           unlist(res[[i]][[j]]$test) - 
                                             unlist(permut.err))
                                       }
                                     }
                                   }
                                   impo[[i]][[j]] <- as.data.frame(
                                     t(sapply(imp.temp, 
                                              function(y) sapply(
                                                as.data.frame(t(sapply(
                                                  y, as.data.frame))), 
                                                function(x) mean(
                                                  unlist(x))))))
                                   rm(nd.bak, nd)
                                 }
                               }
                             }
                             if (err.pooled) {
                               if (is.factor(data[, response])) {
                                 lev <- levels(data[, response])
                                 if (err.train) {
                                   pooled.obs.train <-
                                     factor(lev[pooled.obs.train], 
                                            levels = lev)
                                   pooled.obs.test <-
                                     factor(lev[pooled.obs.test], 
                                            levels = lev)
                                 }
                                 if (is.factor.prediction) {
                                   if (err.train) {
                                     pooled.pred.train <-
                                       factor(lev[pooled.pred.train], 
                                              levels = lev)
                                     pooled.pred.test <-
                                       factor(lev[pooled.pred.test], 
                                              levels = lev)
                                   }
                                 }
                                 pooled.err.train <- NULL
                                 if (err.train) {
                                   pooled.err.train <-
                                     err.fun(pooled.obs.train, 
                                             pooled.pred.train)
                                 }
                                 if (i == 1) {
                                   pooled.err <- t(unlist(list(
                                     train = pooled.err.train, 
                                     test = err.fun(pooled.obs.test,
                                                     pooled.pred.test))))
                                 }
                                 else {
                                   pooled.err <- rbind(pooled.err,
                                                       unlist(list(
                                                         train =
                                                           pooled.err.train, 
                                                         test = err.fun(
                                                           pooled.obs.test,
                                                           pooled.pred.test))))
                                 }
                                 if (do.gc >= 2) {
                                   gc()
                                 }
                               }
                               if ((do.gc >= 1) & (do.gc < 2)) {
                                 gc()
                               }
                               if (err.unpooled & err.pooled) {
                                 foreach.out <- list(pooled.err, res)
                                 return(foreach.out)
                               }
                               if (err.pooled & !err.unpooled) {
                                 return(pooled.err)
                               }
                               if (!err.pooled & err.unpooled) {
                                 return(res)
                               }
                             }
                           }
    stopCluster(cl)
    
    
    if (err.pooled & !err.unpooled) {
      pooled.err <- as.data.frame(foreach.out)
    }
    if (err.pooled & err.unpooled) {
      for (i in 1:length(resamp)) {
        foreach.out[[i]] <- as.data.frame(foreach.out[[i]])
      }
      for (i in 2:length(resamp)) {
        foreach.out[[1]] <- merge.data.frame(foreach.out[[1]], 
                                             foreach.out[[i]], all = TRUE)
      }
      i <- 2
      while (i <= length(resamp)) {
        foreach.out[[2]] <- NULL
        i <- i + 1
      }
    }
  }
  else {
    for (i in 1:length(resamp)) {
      if (silent == 1) 
        cat(date(), "Repetition", names(resamp)[i], "\n")
      if (err.train) {
        pooled.obs.train = pooled.pred.train = c()
        pooled.obs.test = pooled.pred.test = c()
      }
      for (j in 1:length(resamp[[i]])) {
        if (silent == 2) 
          cat(date(), "- Fold", j, "\n")
        nd <- data[resamp[[i]][[j]]$train, ]
        if (!is.null(train.fun)) {
          nd <- train.fun(data = nd, param = train.param)
        }
        margs <- c(list(formula = formula, data = nd), model.args)
        if (do.try) {
          fit <- try(do.call(model.fun, args = margs), silent = silent)
          if (class(fit) == "try-error") {
            fit <- NULL
            if (err.unpooled) {
              if (err.train) {
                res[[i]][[j]]$train <- NULL
                res[[i]][[j]]$test <- NULL
              }
              if (importance) {
                impo[[i]][[j]] <- c()
              }
            }
            if (do.gc >= 2) {
              gc()
            }
            next
          }
        }
        else {
          fit <- do.call(model.fun, args = margs)
        }
        if (err.train) {
          pargs <- c(list(object = fit, newdata = nd), pred.args)
          if (is.null(pred.fun)) {
            pred.train = do.call(predict, args = pargs)
          }
          else {
            pred.train <- do.call(pred.fun, args = pargs)
          }
          rm(pargs)
          if (err.unpooled) 
            if (do.try) {
              err.try <- try(err.fun(nd[, response], pred.train), 
                             silent = silent)
              if (class(err.try) == "try-error") {
                err.try = NULL
              }
              res[[i]][[j]]$train <- err.try
            }
          else {
            res[[i]][[j]]$train <- err.fun(nd[, response], pred.train)
          }
          if (err.pooled) {
            pooled.obs.train <- c(pooled.obs.train, nd[, response])
            pooled.pred.train <- c(pooled.pred.train, pred.train)
          }
        }
        else {
          if (err.unpooled) {
            res[[i]][[j]]$train <- NULL
          }
        }
        nd <- data[resamp[[i]][[j]]$test, ]
        if (!is.null(test.fun)) {
          nd <- test.fun(data = nd, param = test.param)
        }
        if (importance) {
          nd.bak <- nd
        }
        pargs <- c(list(object = fit, newdata = nd), pred.args)
        if (is.null(pred.fun)) {
          pred.test <- do.call(predict, args = pargs)
        }
        else {
          pred.test <- do.call(pred.fun, args = pargs)
        }
        rm(pargs)
        if (err.unpooled) {
          if (do.try) {
            err.try <- try(err.fun(nd[, response], pred.test), 
                           silent = silent)
            if (class(err.try) == "try-error") 
              err.try <- NULL
            res[[i]][[j]]$test <- err.try
          }
          else {
            res[[i]][[j]]$test <- err.fun(nd[, response], pred.test)
          }
        }
        if (err.pooled) {
          pooled.obs.test <- c(pooled.obs.test, nd[, response])
          pooled.pred.test <- c(pooled.pred.test, pred.test)
          is.factor.prediction <- is.factor(pred.test)
        }
        if (importance & err.unpooled) {
          if (is.null(res[[i]][[j]]$test)) {
            impo[[i]][[j]] <- c()
            if (silent == 1 | silent == 2) 
              cat(date(), "-- skipping variable importance\n")
          }
          else {
            if (silent == 1 | silent == 2) {
              cat(date(), "-- Variable importance\n")
            }
            imp.temp <- imp.one.rep
            for (cnt in 1:imp.permutations) {
              if (silent == 1 | silent == 2 & (cnt > 1)) {
                if (log10(cnt) == floor(log10(cnt))) {
                  cat(date(), "   ", cnt, "\n")
                }
              }
              permut <- sample(1:nrow(nd), replace = FALSE)
              for (vnm in imp.variables) {
                nd <- nd.bak
                nd[, vnm] <- nd[, vnm][permut]
                pargs <- c(list(object = fit, newdata = nd), 
                           pred.args)
                if (is.null(pred.fun)) {
                  pred.test = do.call(predict, args = pargs)
                }
                else {
                  pred.test <- do.call(pred.fun, args = pargs)
                }
                rm(pargs)
                if (do.try) {
                  permut.err <- try(err.fun(nd[, response], pred.test), 
                                    silent = silent)
                  if (class(permut.err) == "try-error") {
                    imp.temp[[vnm]][[cnt]] <- c()
                  }
                  else {
                    imp.temp[[vnm]][[cnt]] <-
                      as.list(unlist(res[[i]][[j]]$test) - unlist(permut.err))
                  }
                }
                else {
                  permut.err <- err.fun(nd[, response], pred.test)
                  imp.temp[[vnm]][[cnt]] <- 
                    as.list(unlist(res[[i]][[j]]$test) - unlist(permut.err))
                }
              }
            }
            impo[[i]][[j]] <- as.data.frame(t(sapply(imp.temp, function(y) 
              sapply(as.data.frame(t(sapply(y, as.data.frame))),
                     function(x) mean(unlist(x))))))
            rm(nd.bak, nd)
          }
        }
      }
      if (err.pooled) {
        if (is.factor(data[, response])) {
          lev <- levels(data[, response])
          if (err.train) {
            pooled.obs.train <- factor(lev[pooled.obs.train], levels = lev)
            pooled.obs.test <- factor(lev[pooled.obs.test], levels = lev)
          }
          if (is.factor.prediction) {
            if (err.train) {
              pooled.pred.train <- factor(lev[pooled.pred.train], levels = lev)
              pooled.pred.test <- factor(lev[pooled.pred.test], levels = lev)
            }
          }
        }
        pooled.err.train <- NULL
        if (err.train) 
          pooled.err.train <- err.fun(pooled.obs.train, pooled.pred.train)
        if (i == 1) {
          pooled.err <- t(unlist(list(train = pooled.err.train, 
                                      test = err.fun(pooled.obs.test,
                                                     pooled.pred.test))))
        }
        else {
          pooled.err <- rbind(pooled.err, 
                              unlist(list(train = pooled.err.train, 
                                          test = err.fun(pooled.obs.test,
                                                         pooled.pred.test))))
        }
        if (do.gc >= 2) {
          gc()
        }
      }
      if ((do.gc >= 1) & (do.gc < 2)) {
        gc()
      }
    }
  }
  
  if (silent == 1 | silent == 2) {
    cat(date(), "Done.\n")
  }
  if (importance) {
    class(impo) <- "sperrorestimportance"
  }
  
  if (parallel) {
    if (err.pooled & err.unpooled) {
      sperr.vers <- packageVersion("sperrorest")
      res <- foreach.out
      res[[1]] <- NULL
      RES <- list(error = res[[1]], 
                  represampling = resamp, pooled.error = foreach.out[[1]], 
                  importance = impo, packageVersion = sperr.vers)
      class(RES) <- "sperrorest"
      return(RES)
    }
    if (err.pooled & !err.unpooled) {
      sperr.vers <- packageVersion("sperrorest")
      RES <- list(error = NULL, represampling = resamp, 
                  pooled.error = pooled.err, importance = impo, 
                  packageVersion = sperr.vers)
      class(RES) <- "sperrorest"
      return(RES)
    }
    if (!err.pooled & err.unpooled) {
      sperr.vers <- packageVersion("sperrorest")
      RES <- list(error = foreach.out, represampling = resamp, 
                  pooled.error = NULL, importance = impo, 
                  packageVersion = sperr.vers)
      class(RES) <- "sperrorest"
      return(RES)
    }
  }
  else {
    sperr.vers <- packageVersion("sperrorest")
    RES <- list(error = res, represampling = resamp, 
                pooled.error = pooled.err, 
                importance = impo, packageVersion = sperr.vers)
    class(RES) <- "sperrorest"
    return(RES)
  }
}
```

```{r data and packages, echo = FALSE}
require(sperrorest)
require(rpart)
require(foreach)
require(doParallel)
data(ecuador, package = "sperrorest")
```

# Examples
## `mysperrorest` example (`parallel = TRUE`).  
- 100 repetitions
- 2 folds
- 2 cores 

```{r}
print(Sys.time())
fo <- slides ~ dem + slope + hcurv + vcurv +
  log.carea + cslope
mypred.rpart <- function(object, newdata) predict(object, newdata)[, 2]
ctrl <- rpart.control(cp = 0.005)

time <- Sys.time()
foreach.out <- sperrorest.par(fo, data = ecuador,
                              model.fun = rpart, model.args = list(control = ctrl),
                              pred.fun = mypred.rpart,
                              smp.fun = partition.cv, 
                              smp.args = list(repetition = 1:5, nfold = 5),
                              par.units = 2, silent = 2,
                              err.fold = T, err.rep = T)
print(Sys.time() - time)
```

## `mysperrorest` example (`parallel = FALSE`).  
- 100 repetitions
- 2 folds
- 2 cores  

Note the time difference compared with Example #1
```{r}
print(Sys.time())
fo <- slides ~ dem + slope + hcurv + vcurv +
  log.carea + cslope
mypred.rpart <- function(object, newdata) predict(object, newdata)[, 2]
ctrl <- rpart.control(cp = 0.005)

time <- Sys.time()
CV_nopar <- mysperro(fo, data = ecuador,
                model.fun = rpart, model.args = list(control = ctrl),
                pred.fun = mypred.rpart,
                smp.fun = partition.cv, 
                smp.args = list(repetition = 1:100, nfold = 10),
                parallel = FALSE, silent = FALSE,
                err.pooled = TRUE, err.unpooled = TRUE)
print(Sys.time() - time)
```

## Code von Tobias Herrmann

```{r}
print(Sys.time())
fo <- slides ~ dem + slope + hcurv + vcurv +
  log.carea + cslope
mypred.rpart <- function(object, newdata) predict(object, newdata)[, 2]
ctrl <- rpart.control(cp = 0.005)

time <- Sys.time()
CV_TH <- parsperrorest(fo, data = ecuador,
                model.fun = rpart, model.args = list(control = ctrl),
                pred.fun = mypred.rpart,
                smp.fun = partition.cv, 
                smp.args = list(repetition = 1:20, nfold = 10), 
                silent = F,
                par.args = list(par.mode = 1, par.units=2, lb = F, high=F), 
                benchmark = TRUE,
                err.pooled = TRUE, err.unpooled = TRUE)
print(Sys.time() - time)
```

